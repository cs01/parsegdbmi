<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>pygdbmi.gdbcontroller API documentation</title>
<meta name="description" content="GdbController class to programatically run gdb and get structured output" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pygdbmi.gdbcontroller</code></h1>
</header>
<section id="section-intro">
<p>GdbController class to programatically run gdb and get structured output</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;GdbController class to programatically run gdb and get structured output&#34;&#34;&#34;

import logging
import os
import select
import signal
import subprocess
import sys
import time
from distutils.spawn import find_executable
from pprint import pformat
from typing import Union, List, Optional

from pygdbmi import gdbmiparser

try:  # py3
    from shlex import quote
except ImportError:  # py2
    from pipes import quote

PYTHON3 = sys.version_info.major == 3
DEFAULT_GDB_TIMEOUT_SEC = 1
DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC = 0.2
USING_WINDOWS = os.name == &#34;nt&#34;
if USING_WINDOWS:
    import msvcrt
    from ctypes import windll, byref, wintypes, WinError, POINTER  # type: ignore
    from ctypes.wintypes import HANDLE, DWORD, BOOL
else:
    import fcntl

SIGNAL_NAME_TO_NUM = {}
for n in dir(signal):
    if n.startswith(&#34;SIG&#34;) and &#34;_&#34; not in n:
        SIGNAL_NAME_TO_NUM[n.upper()] = getattr(signal, n)


class NoGdbProcessError(ValueError):
    &#34;&#34;&#34;Raise when trying to interact with gdb subprocess, but it does not exist.
    It may have been killed and removed, or failed to initialize for some reason.&#34;&#34;&#34;

    pass


class GdbTimeoutError(ValueError):
    &#34;&#34;&#34;Raised when no response is recieved from gdb after the timeout has been triggered&#34;&#34;&#34;

    pass


class GdbController:
    &#34;&#34;&#34;
    Run gdb as a subprocess. Send commands and receive structured output.
    Create new object, along with a gdb subprocess

    Args:
        gdb_path (str): Command to run in shell to spawn new gdb subprocess
        gdb_args (list): Arguments to pass to shell when spawning new gdb subprocess
        time_to_check_for_additional_output_sec (float): When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If &lt;= 0, full timeout time is used.
        rr (bool): Use the `rr replay` command instead of `gdb`. See rr-project.org for more info.
        verbose (bool): Print verbose output if True
    Returns:
        New GdbController object
    &#34;&#34;&#34;

    def __init__(
        self,
        gdb_path: str = &#34;gdb&#34;,
        gdb_args: Optional[List] = None,
        time_to_check_for_additional_output_sec=DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC,
        rr: bool = False,
        verbose: bool = False,
    ):
        if gdb_args is None:
            default_gdb_args = [&#34;--nx&#34;, &#34;--quiet&#34;, &#34;--interpreter=mi2&#34;]
            gdb_args = default_gdb_args

        self.verbose = verbose
        self.abs_gdb_path = None  # abs path to gdb executable
        self.cmd = []  # type: : List[str] the shell command to run gdb
        self.time_to_check_for_additional_output_sec = (
            time_to_check_for_additional_output_sec
        )
        self.gdb_process = None
        self._allow_overwrite_timeout_times = (
            self.time_to_check_for_additional_output_sec &gt; 0
        )

        if rr:
            self.cmd = [&#34;rr&#34;, &#34;replay&#34;] + gdb_args

        else:
            if not gdb_path:
                raise ValueError(&#34;a valid path to gdb must be specified&#34;)

            else:
                abs_gdb_path = find_executable(gdb_path)
                if abs_gdb_path is None:
                    raise ValueError(
                        &#39;gdb executable could not be resolved from &#34;%s&#34;&#39; % gdb_path
                    )

                else:
                    self.abs_gdb_path = abs_gdb_path
            self.cmd = [self.abs_gdb_path] + gdb_args

        self._attach_logger(verbose)
        self.spawn_new_gdb_subprocess()

    def _attach_logger(self, verbose: bool):
        handler = logging.StreamHandler()
        handler.setFormatter(logging.Formatter(&#34;%(message)s&#34;))
        unique_number = time.time()
        self.logger = logging.getLogger(__name__ + &#34;.&#34; + str(unique_number))
        self.logger.propagate = False
        if verbose:
            level = logging.DEBUG
        else:
            level = logging.ERROR
        self.logger.setLevel(level)
        self.logger.addHandler(handler)

    def get_subprocess_cmd(self):
        &#34;&#34;&#34;Returns the shell-escaped string used to invoke the gdb subprocess.
        This is a string that can be executed directly in a shell.
        &#34;&#34;&#34;
        return &#34; &#34;.join(quote(c) for c in self.cmd)

    def spawn_new_gdb_subprocess(self):
        &#34;&#34;&#34;Spawn a new gdb subprocess with the arguments supplied to the object
        during initialization. If gdb subprocess already exists, terminate it before
        spanwing a new one.
        Return int: gdb process id
        &#34;&#34;&#34;
        if self.gdb_process:
            self.logger.debug(
                &#34;Killing current gdb subprocess (pid %d)&#34; % self.gdb_process.pid
            )
            self.exit()

        self.logger.debug(&#39;Launching gdb: &#34;%s&#34;&#39; % &#34; &#34;.join(self.cmd))

        # Use pipes to the standard streams
        self.gdb_process = subprocess.Popen(
            self.cmd,
            shell=False,
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE,
            stderr=subprocess.PIPE,
            bufsize=0,
        )

        _make_non_blocking(self.gdb_process.stdout)
        _make_non_blocking(self.gdb_process.stderr)

        # save file numbers for use later
        self.stdout_fileno = self.gdb_process.stdout.fileno()
        self.stderr_fileno = self.gdb_process.stderr.fileno()
        self.stdin_fileno = self.gdb_process.stdin.fileno()

        self.read_list = [self.stdout_fileno, self.stderr_fileno]
        self.write_list = [self.stdin_fileno]

        # string buffers for unifinished gdb output
        self._incomplete_output = {&#34;stdout&#34;: None, &#34;stderr&#34;: None}
        return self.gdb_process.pid

    def verify_valid_gdb_subprocess(self):
        &#34;&#34;&#34;Verify there is a process object, and that it is still running.
        Raise NoGdbProcessError if either of the above are not true.&#34;&#34;&#34;
        if not self.gdb_process:
            raise NoGdbProcessError(&#34;gdb process is not attached&#34;)

        elif self.gdb_process.poll() is not None:
            raise NoGdbProcessError(
                &#34;gdb process has already finished with return code: %s&#34;
                % str(self.gdb_process.poll())
            )

    def write(
        self,
        mi_cmd_to_write: Union[str, List[str]],
        timeout_sec=DEFAULT_GDB_TIMEOUT_SEC,
        raise_error_on_timeout: bool = True,
        read_response: bool = True,
    ):
        &#34;&#34;&#34;Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec.

        Args:
            mi_cmd_to_write (str or list): String to write to gdb. If list, it is joined by newlines.
            timeout_sec (float): Maximum number of seconds to wait for response before exiting. Must be &gt;= 0.
            raise_error_on_timeout (bool): If read_response is True, raise error if no response is received
            read_response (bool): Block and read response. If there is a separate thread running,
            this can be false, and the reading thread read the output.
        Returns:
            List of parsed gdb responses if read_response is True, otherwise []
        Raises:
            NoGdbProcessError if there is no gdb subprocess running
            TypeError if mi_cmd_to_write is not valid
        &#34;&#34;&#34;
        self.verify_valid_gdb_subprocess()
        if timeout_sec &lt; 0:
            self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
            timeout_sec = 0

        # Ensure proper type of the mi command
        if isinstance(mi_cmd_to_write, str):
            mi_cmd_to_write_str = mi_cmd_to_write
        elif isinstance(mi_cmd_to_write, list):
            mi_cmd_to_write_str = &#34;\n&#34;.join(mi_cmd_to_write)
        else:
            raise TypeError(
                &#34;The gdb mi command must a be str or list. Got &#34;
                + str(type(mi_cmd_to_write))
            )

        self.logger.debug(&#34;writing: %s&#34;, mi_cmd_to_write)

        if not mi_cmd_to_write_str.endswith(&#34;\n&#34;):
            mi_cmd_to_write_nl = mi_cmd_to_write_str + &#34;\n&#34;
        else:
            mi_cmd_to_write_nl = mi_cmd_to_write_str

        if USING_WINDOWS:
            # select not implemented in windows for pipes
            # assume it&#39;s always ready
            outputready = [self.stdin_fileno]
        else:
            _, outputready, _ = select.select([], self.write_list, [], timeout_sec)
        for fileno in outputready:
            if fileno == self.stdin_fileno:
                # ready to write
                self.gdb_process.stdin.write(  # type: ignore
                    mi_cmd_to_write_nl.encode()
                )
                # don&#39;t forget to flush for Python3, otherwise gdb won&#39;t realize there is data
                # to evaluate, and we won&#39;t get a response
                self.gdb_process.stdin.flush()  # type: ignore
            else:
                self.logger.error(&#34;got unexpected fileno %d&#34; % fileno)

        if read_response is True:
            return self.get_gdb_response(
                timeout_sec=timeout_sec, raise_error_on_timeout=raise_error_on_timeout
            )

        else:
            return []

    def get_gdb_response(
        self,
        timeout_sec: float = DEFAULT_GDB_TIMEOUT_SEC,
        raise_error_on_timeout=True,
        return_on_first_response=False,
    ):
        &#34;&#34;&#34;Get response from GDB, and block while doing so. If GDB does not have any response ready to be read
        by timeout_sec, an exception is raised.

        Args:
            timeout_sec (float): Maximum time to wait for reponse. Must be &gt;= 0. Will return after
            raise_error_on_timeout (bool): Whether an exception should be raised if no response was found after timeout_sec
            return_on_first_response (bool): Return as soon as at least one response from gdb has been parsed. This may result in faster return times, but also may leave some arguments remaining to be parsed.

        Returns:
            List of parsed GDB responses, returned from gdbmiparser.parse_response, with the
            additional key &#39;stream&#39; which is either &#39;stdout&#39; or &#39;stderr&#39;

        Raises:
            GdbTimeoutError if response is not received within timeout_sec
            ValueError if select returned unexpected file number
            NoGdbProcessError if there is no gdb subprocess running
        &#34;&#34;&#34;

        self.verify_valid_gdb_subprocess()
        if timeout_sec &lt; 0:
            self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
            timeout_sec = 0

        if USING_WINDOWS:
            retval = self._get_responses_windows(timeout_sec, return_on_first_response)
        else:
            retval = self._get_responses_unix(timeout_sec, return_on_first_response)

        if not retval and raise_error_on_timeout:
            raise GdbTimeoutError(
                &#34;Did not get response from gdb after %s seconds&#34; % timeout_sec
            )

        else:
            return retval

    def _get_responses_windows(self, timeout_sec, return_on_first_response):
        &#34;&#34;&#34;Get responses on windows. Assume no support for select and use a while loop.&#34;&#34;&#34;
        timeout_time_sec = time.time() + timeout_sec
        responses = []
        while True:
            try:
                self.gdb_process.stdout.flush()
                if PYTHON3:
                    raw_output = self.gdb_process.stdout.readline().replace(
                        b&#34;\r&#34;, b&#34;\n&#34;
                    )
                else:
                    raw_output = self.gdb_process.stdout.read().replace(b&#34;\r&#34;, b&#34;\n&#34;)
                responses += self._get_responses_list(raw_output, &#34;stdout&#34;)
            except IOError:
                pass

            try:
                self.gdb_process.stderr.flush()
                if PYTHON3:
                    raw_output = self.gdb_process.stderr.readline().replace(
                        b&#34;\r&#34;, b&#34;\n&#34;
                    )
                else:
                    raw_output = self.gdb_process.stderr.read().replace(b&#34;\r&#34;, b&#34;\n&#34;)
                responses += self._get_responses_list(raw_output, &#34;stderr&#34;)
            except IOError:
                pass

            if time.time() &gt; timeout_time_sec:
                break
            elif responses and return_on_first_response:
                break

        return responses

    def _get_responses_unix(self, timeout_sec, return_on_first_response):
        &#34;&#34;&#34;Get responses on unix-like system. Use select to wait for output.&#34;&#34;&#34;
        timeout_time_sec = time.time() + timeout_sec
        responses = []
        while True:
            select_timeout = timeout_time_sec - time.time()
            # I prefer to not pass a negative value to select
            if select_timeout &lt;= 0:
                select_timeout = 0
            events, _, _ = select.select(self.read_list, [], [], select_timeout)
            responses_list = None  # to avoid infinite loop if using Python 2
            try:
                for fileno in events:
                    # new data is ready to read
                    if fileno == self.stdout_fileno:
                        self.gdb_process.stdout.flush()
                        raw_output = self.gdb_process.stdout.read()
                        stream = &#34;stdout&#34;

                    elif fileno == self.stderr_fileno:
                        self.gdb_process.stderr.flush()
                        raw_output = self.gdb_process.stderr.read()
                        stream = &#34;stderr&#34;

                    else:
                        raise ValueError(
                            &#34;Developer error. Got unexpected file number %d&#34; % fileno
                        )

                    responses_list = self._get_responses_list(raw_output, stream)
                    responses += responses_list

            except IOError:  # only occurs in python 2.7
                pass

            if timeout_sec == 0:  # just exit immediately
                break

            elif responses_list and self._allow_overwrite_timeout_times:
                # update timeout time to potentially be closer to now to avoid lengthy wait times when nothing is being output by gdb
                timeout_time_sec = min(
                    time.time() + self.time_to_check_for_additional_output_sec,
                    timeout_time_sec,
                )

            elif time.time() &gt; timeout_time_sec:
                break
            elif responses and return_on_first_response:
                break

        return responses

    def _get_responses_list(self, raw_output, stream):
        &#34;&#34;&#34;Get parsed response list from string output
        Args:
            raw_output (unicode): gdb output to parse
            stream (str): either stdout or stderr
        &#34;&#34;&#34;
        responses = []

        raw_output, self._incomplete_output[stream] = _buffer_incomplete_responses(
            raw_output, self._incomplete_output.get(stream)
        )

        if not raw_output:
            return responses

        response_list = list(
            filter(lambda x: x, raw_output.decode(errors=&#34;replace&#34;).split(&#34;\n&#34;))
        )  # remove blank lines

        # parse each response from gdb into a dict, and store in a list
        for response in response_list:
            if gdbmiparser.response_is_finished(response):
                pass
            else:
                parsed_response = gdbmiparser.parse_response(response)
                parsed_response[&#34;stream&#34;] = stream

                self.logger.debug(&#34;%s&#34;, pformat(parsed_response))

                responses.append(parsed_response)

        return responses

    def send_signal_to_gdb(self, signal_input):
        &#34;&#34;&#34;Send signal name (case insensitive) or number to gdb subprocess
        gdbmi.send_signal_to_gdb(2)  # valid
        gdbmi.send_signal_to_gdb(&#39;sigint&#39;)  # also valid
        gdbmi.send_signal_to_gdb(&#39;SIGINT&#39;)  # also valid

        raises ValueError if signal_input is invalie
        raises NoGdbProcessError if there is no gdb process to send a signal to
        &#34;&#34;&#34;
        try:
            signal = int(signal_input)
        except Exception:
            signal = SIGNAL_NAME_TO_NUM.get(signal_input.upper())

        if not signal:
            raise ValueError(
                &#39;Could not find signal corresponding to &#34;%s&#34;&#39; % str(signal)
            )

        if self.gdb_process:
            os.kill(self.gdb_process.pid, signal)
        else:
            raise NoGdbProcessError(
                &#34;Cannot send signal to gdb process because no process exists.&#34;
            )

    def interrupt_gdb(self):
        &#34;&#34;&#34;Send SIGINT (interrupt signal) to the gdb subprocess&#34;&#34;&#34;
        self.send_signal_to_gdb(&#34;SIGINT&#34;)

    def exit(self):
        &#34;&#34;&#34;Terminate gdb process
        Returns: None&#34;&#34;&#34;
        if self.gdb_process:
            self.gdb_process.terminate()
            self.gdb_process.communicate()
        self.gdb_process = None
        return None


def _buffer_incomplete_responses(raw_output, buf):
    &#34;&#34;&#34;It is possible for some of gdb&#39;s output to be read before it completely finished its response.
    In that case, a partial mi response was read, which cannot be parsed into structured data.
    We want to ALWAYS parse complete mi records. To do this, we store a buffer of gdb&#39;s
    output if the output did not end in a newline.

    Args:
        raw_output: Contents of the gdb mi output
        buf (str): Buffered gdb response from the past. This is incomplete and needs to be prepended to
        gdb&#39;s next output.

    Returns:
        (raw_output, buf)
    &#34;&#34;&#34;

    if raw_output:
        if buf:
            # concatenate buffer and new output
            raw_output = b&#34;&#34;.join([buf, raw_output])
            buf = None

        if b&#34;\n&#34; not in raw_output:
            # newline was not found, so assume output is incomplete and store in buffer
            buf = raw_output
            raw_output = None

        elif not raw_output.endswith(b&#34;\n&#34;):
            # raw output doesn&#39;t end in a newline, so store everything after the last newline (if anything)
            # in the buffer, and parse everything before it
            remainder_offset = raw_output.rindex(b&#34;\n&#34;) + 1
            buf = raw_output[remainder_offset:]
            raw_output = raw_output[:remainder_offset]

    return (raw_output, buf)


def _make_non_blocking(file_obj):
    &#34;&#34;&#34;make file object non-blocking
    Windows doesn&#39;t have the fcntl module, but someone on
    stack overflow supplied this code as an answer, and it works
    http://stackoverflow.com/a/34504971/2893090&#34;&#34;&#34;

    if USING_WINDOWS:
        LPDWORD = POINTER(DWORD)
        PIPE_NOWAIT = wintypes.DWORD(0x00000001)

        SetNamedPipeHandleState = windll.kernel32.SetNamedPipeHandleState
        SetNamedPipeHandleState.argtypes = [HANDLE, LPDWORD, LPDWORD, LPDWORD]
        SetNamedPipeHandleState.restype = BOOL

        h = msvcrt.get_osfhandle(file_obj.fileno())

        res = windll.kernel32.SetNamedPipeHandleState(h, byref(PIPE_NOWAIT), None, None)
        if res == 0:
            raise ValueError(WinError())

    else:
        # Set the file status flag (F_SETFL) on the pipes to be non-blocking
        # so we can attempt to read from a pipe with no new data without locking
        # the program up
        fcntl.fcntl(file_obj, fcntl.F_SETFL, os.O_NONBLOCK)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pygdbmi.gdbcontroller.GdbController"><code class="flex name class">
<span>class <span class="ident">GdbController</span></span>
<span>(</span><span>gdb_path='gdb', gdb_args=None, time_to_check_for_additional_output_sec=0.2, rr=False, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Run gdb as a subprocess. Send commands and receive structured output.
Create new object, along with a gdb subprocess</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gdb_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Command to run in shell to spawn new gdb subprocess</dd>
<dt><strong><code>gdb_args</code></strong> :&ensp;<code>list</code></dt>
<dd>Arguments to pass to shell when spawning new gdb subprocess</dd>
<dt><strong><code>time_to_check_for_additional_output_sec</code></strong> :&ensp;<code>float</code></dt>
<dd>When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If &lt;= 0, full timeout time is used.</dd>
<dt><strong><code>rr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Use the <code>rr replay</code> command instead of <code>gdb</code>. See rr-project.org for more info.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Print verbose output if True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>New</code> <a title="pygdbmi.gdbcontroller.GdbController" href="#pygdbmi.gdbcontroller.GdbController"><code>GdbController</code></a> <code>object</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class GdbController:
    &#34;&#34;&#34;
    Run gdb as a subprocess. Send commands and receive structured output.
    Create new object, along with a gdb subprocess

    Args:
        gdb_path (str): Command to run in shell to spawn new gdb subprocess
        gdb_args (list): Arguments to pass to shell when spawning new gdb subprocess
        time_to_check_for_additional_output_sec (float): When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If &lt;= 0, full timeout time is used.
        rr (bool): Use the `rr replay` command instead of `gdb`. See rr-project.org for more info.
        verbose (bool): Print verbose output if True
    Returns:
        New GdbController object
    &#34;&#34;&#34;

    def __init__(
        self,
        gdb_path: str = &#34;gdb&#34;,
        gdb_args: Optional[List] = None,
        time_to_check_for_additional_output_sec=DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC,
        rr: bool = False,
        verbose: bool = False,
    ):
        if gdb_args is None:
            default_gdb_args = [&#34;--nx&#34;, &#34;--quiet&#34;, &#34;--interpreter=mi2&#34;]
            gdb_args = default_gdb_args

        self.verbose = verbose
        self.abs_gdb_path = None  # abs path to gdb executable
        self.cmd = []  # type: : List[str] the shell command to run gdb
        self.time_to_check_for_additional_output_sec = (
            time_to_check_for_additional_output_sec
        )
        self.gdb_process = None
        self._allow_overwrite_timeout_times = (
            self.time_to_check_for_additional_output_sec &gt; 0
        )

        if rr:
            self.cmd = [&#34;rr&#34;, &#34;replay&#34;] + gdb_args

        else:
            if not gdb_path:
                raise ValueError(&#34;a valid path to gdb must be specified&#34;)

            else:
                abs_gdb_path = find_executable(gdb_path)
                if abs_gdb_path is None:
                    raise ValueError(
                        &#39;gdb executable could not be resolved from &#34;%s&#34;&#39; % gdb_path
                    )

                else:
                    self.abs_gdb_path = abs_gdb_path
            self.cmd = [self.abs_gdb_path] + gdb_args

        self._attach_logger(verbose)
        self.spawn_new_gdb_subprocess()

    def _attach_logger(self, verbose: bool):
        handler = logging.StreamHandler()
        handler.setFormatter(logging.Formatter(&#34;%(message)s&#34;))
        unique_number = time.time()
        self.logger = logging.getLogger(__name__ + &#34;.&#34; + str(unique_number))
        self.logger.propagate = False
        if verbose:
            level = logging.DEBUG
        else:
            level = logging.ERROR
        self.logger.setLevel(level)
        self.logger.addHandler(handler)

    def get_subprocess_cmd(self):
        &#34;&#34;&#34;Returns the shell-escaped string used to invoke the gdb subprocess.
        This is a string that can be executed directly in a shell.
        &#34;&#34;&#34;
        return &#34; &#34;.join(quote(c) for c in self.cmd)

    def spawn_new_gdb_subprocess(self):
        &#34;&#34;&#34;Spawn a new gdb subprocess with the arguments supplied to the object
        during initialization. If gdb subprocess already exists, terminate it before
        spanwing a new one.
        Return int: gdb process id
        &#34;&#34;&#34;
        if self.gdb_process:
            self.logger.debug(
                &#34;Killing current gdb subprocess (pid %d)&#34; % self.gdb_process.pid
            )
            self.exit()

        self.logger.debug(&#39;Launching gdb: &#34;%s&#34;&#39; % &#34; &#34;.join(self.cmd))

        # Use pipes to the standard streams
        self.gdb_process = subprocess.Popen(
            self.cmd,
            shell=False,
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE,
            stderr=subprocess.PIPE,
            bufsize=0,
        )

        _make_non_blocking(self.gdb_process.stdout)
        _make_non_blocking(self.gdb_process.stderr)

        # save file numbers for use later
        self.stdout_fileno = self.gdb_process.stdout.fileno()
        self.stderr_fileno = self.gdb_process.stderr.fileno()
        self.stdin_fileno = self.gdb_process.stdin.fileno()

        self.read_list = [self.stdout_fileno, self.stderr_fileno]
        self.write_list = [self.stdin_fileno]

        # string buffers for unifinished gdb output
        self._incomplete_output = {&#34;stdout&#34;: None, &#34;stderr&#34;: None}
        return self.gdb_process.pid

    def verify_valid_gdb_subprocess(self):
        &#34;&#34;&#34;Verify there is a process object, and that it is still running.
        Raise NoGdbProcessError if either of the above are not true.&#34;&#34;&#34;
        if not self.gdb_process:
            raise NoGdbProcessError(&#34;gdb process is not attached&#34;)

        elif self.gdb_process.poll() is not None:
            raise NoGdbProcessError(
                &#34;gdb process has already finished with return code: %s&#34;
                % str(self.gdb_process.poll())
            )

    def write(
        self,
        mi_cmd_to_write: Union[str, List[str]],
        timeout_sec=DEFAULT_GDB_TIMEOUT_SEC,
        raise_error_on_timeout: bool = True,
        read_response: bool = True,
    ):
        &#34;&#34;&#34;Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec.

        Args:
            mi_cmd_to_write (str or list): String to write to gdb. If list, it is joined by newlines.
            timeout_sec (float): Maximum number of seconds to wait for response before exiting. Must be &gt;= 0.
            raise_error_on_timeout (bool): If read_response is True, raise error if no response is received
            read_response (bool): Block and read response. If there is a separate thread running,
            this can be false, and the reading thread read the output.
        Returns:
            List of parsed gdb responses if read_response is True, otherwise []
        Raises:
            NoGdbProcessError if there is no gdb subprocess running
            TypeError if mi_cmd_to_write is not valid
        &#34;&#34;&#34;
        self.verify_valid_gdb_subprocess()
        if timeout_sec &lt; 0:
            self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
            timeout_sec = 0

        # Ensure proper type of the mi command
        if isinstance(mi_cmd_to_write, str):
            mi_cmd_to_write_str = mi_cmd_to_write
        elif isinstance(mi_cmd_to_write, list):
            mi_cmd_to_write_str = &#34;\n&#34;.join(mi_cmd_to_write)
        else:
            raise TypeError(
                &#34;The gdb mi command must a be str or list. Got &#34;
                + str(type(mi_cmd_to_write))
            )

        self.logger.debug(&#34;writing: %s&#34;, mi_cmd_to_write)

        if not mi_cmd_to_write_str.endswith(&#34;\n&#34;):
            mi_cmd_to_write_nl = mi_cmd_to_write_str + &#34;\n&#34;
        else:
            mi_cmd_to_write_nl = mi_cmd_to_write_str

        if USING_WINDOWS:
            # select not implemented in windows for pipes
            # assume it&#39;s always ready
            outputready = [self.stdin_fileno]
        else:
            _, outputready, _ = select.select([], self.write_list, [], timeout_sec)
        for fileno in outputready:
            if fileno == self.stdin_fileno:
                # ready to write
                self.gdb_process.stdin.write(  # type: ignore
                    mi_cmd_to_write_nl.encode()
                )
                # don&#39;t forget to flush for Python3, otherwise gdb won&#39;t realize there is data
                # to evaluate, and we won&#39;t get a response
                self.gdb_process.stdin.flush()  # type: ignore
            else:
                self.logger.error(&#34;got unexpected fileno %d&#34; % fileno)

        if read_response is True:
            return self.get_gdb_response(
                timeout_sec=timeout_sec, raise_error_on_timeout=raise_error_on_timeout
            )

        else:
            return []

    def get_gdb_response(
        self,
        timeout_sec: float = DEFAULT_GDB_TIMEOUT_SEC,
        raise_error_on_timeout=True,
        return_on_first_response=False,
    ):
        &#34;&#34;&#34;Get response from GDB, and block while doing so. If GDB does not have any response ready to be read
        by timeout_sec, an exception is raised.

        Args:
            timeout_sec (float): Maximum time to wait for reponse. Must be &gt;= 0. Will return after
            raise_error_on_timeout (bool): Whether an exception should be raised if no response was found after timeout_sec
            return_on_first_response (bool): Return as soon as at least one response from gdb has been parsed. This may result in faster return times, but also may leave some arguments remaining to be parsed.

        Returns:
            List of parsed GDB responses, returned from gdbmiparser.parse_response, with the
            additional key &#39;stream&#39; which is either &#39;stdout&#39; or &#39;stderr&#39;

        Raises:
            GdbTimeoutError if response is not received within timeout_sec
            ValueError if select returned unexpected file number
            NoGdbProcessError if there is no gdb subprocess running
        &#34;&#34;&#34;

        self.verify_valid_gdb_subprocess()
        if timeout_sec &lt; 0:
            self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
            timeout_sec = 0

        if USING_WINDOWS:
            retval = self._get_responses_windows(timeout_sec, return_on_first_response)
        else:
            retval = self._get_responses_unix(timeout_sec, return_on_first_response)

        if not retval and raise_error_on_timeout:
            raise GdbTimeoutError(
                &#34;Did not get response from gdb after %s seconds&#34; % timeout_sec
            )

        else:
            return retval

    def _get_responses_windows(self, timeout_sec, return_on_first_response):
        &#34;&#34;&#34;Get responses on windows. Assume no support for select and use a while loop.&#34;&#34;&#34;
        timeout_time_sec = time.time() + timeout_sec
        responses = []
        while True:
            try:
                self.gdb_process.stdout.flush()
                if PYTHON3:
                    raw_output = self.gdb_process.stdout.readline().replace(
                        b&#34;\r&#34;, b&#34;\n&#34;
                    )
                else:
                    raw_output = self.gdb_process.stdout.read().replace(b&#34;\r&#34;, b&#34;\n&#34;)
                responses += self._get_responses_list(raw_output, &#34;stdout&#34;)
            except IOError:
                pass

            try:
                self.gdb_process.stderr.flush()
                if PYTHON3:
                    raw_output = self.gdb_process.stderr.readline().replace(
                        b&#34;\r&#34;, b&#34;\n&#34;
                    )
                else:
                    raw_output = self.gdb_process.stderr.read().replace(b&#34;\r&#34;, b&#34;\n&#34;)
                responses += self._get_responses_list(raw_output, &#34;stderr&#34;)
            except IOError:
                pass

            if time.time() &gt; timeout_time_sec:
                break
            elif responses and return_on_first_response:
                break

        return responses

    def _get_responses_unix(self, timeout_sec, return_on_first_response):
        &#34;&#34;&#34;Get responses on unix-like system. Use select to wait for output.&#34;&#34;&#34;
        timeout_time_sec = time.time() + timeout_sec
        responses = []
        while True:
            select_timeout = timeout_time_sec - time.time()
            # I prefer to not pass a negative value to select
            if select_timeout &lt;= 0:
                select_timeout = 0
            events, _, _ = select.select(self.read_list, [], [], select_timeout)
            responses_list = None  # to avoid infinite loop if using Python 2
            try:
                for fileno in events:
                    # new data is ready to read
                    if fileno == self.stdout_fileno:
                        self.gdb_process.stdout.flush()
                        raw_output = self.gdb_process.stdout.read()
                        stream = &#34;stdout&#34;

                    elif fileno == self.stderr_fileno:
                        self.gdb_process.stderr.flush()
                        raw_output = self.gdb_process.stderr.read()
                        stream = &#34;stderr&#34;

                    else:
                        raise ValueError(
                            &#34;Developer error. Got unexpected file number %d&#34; % fileno
                        )

                    responses_list = self._get_responses_list(raw_output, stream)
                    responses += responses_list

            except IOError:  # only occurs in python 2.7
                pass

            if timeout_sec == 0:  # just exit immediately
                break

            elif responses_list and self._allow_overwrite_timeout_times:
                # update timeout time to potentially be closer to now to avoid lengthy wait times when nothing is being output by gdb
                timeout_time_sec = min(
                    time.time() + self.time_to_check_for_additional_output_sec,
                    timeout_time_sec,
                )

            elif time.time() &gt; timeout_time_sec:
                break
            elif responses and return_on_first_response:
                break

        return responses

    def _get_responses_list(self, raw_output, stream):
        &#34;&#34;&#34;Get parsed response list from string output
        Args:
            raw_output (unicode): gdb output to parse
            stream (str): either stdout or stderr
        &#34;&#34;&#34;
        responses = []

        raw_output, self._incomplete_output[stream] = _buffer_incomplete_responses(
            raw_output, self._incomplete_output.get(stream)
        )

        if not raw_output:
            return responses

        response_list = list(
            filter(lambda x: x, raw_output.decode(errors=&#34;replace&#34;).split(&#34;\n&#34;))
        )  # remove blank lines

        # parse each response from gdb into a dict, and store in a list
        for response in response_list:
            if gdbmiparser.response_is_finished(response):
                pass
            else:
                parsed_response = gdbmiparser.parse_response(response)
                parsed_response[&#34;stream&#34;] = stream

                self.logger.debug(&#34;%s&#34;, pformat(parsed_response))

                responses.append(parsed_response)

        return responses

    def send_signal_to_gdb(self, signal_input):
        &#34;&#34;&#34;Send signal name (case insensitive) or number to gdb subprocess
        gdbmi.send_signal_to_gdb(2)  # valid
        gdbmi.send_signal_to_gdb(&#39;sigint&#39;)  # also valid
        gdbmi.send_signal_to_gdb(&#39;SIGINT&#39;)  # also valid

        raises ValueError if signal_input is invalie
        raises NoGdbProcessError if there is no gdb process to send a signal to
        &#34;&#34;&#34;
        try:
            signal = int(signal_input)
        except Exception:
            signal = SIGNAL_NAME_TO_NUM.get(signal_input.upper())

        if not signal:
            raise ValueError(
                &#39;Could not find signal corresponding to &#34;%s&#34;&#39; % str(signal)
            )

        if self.gdb_process:
            os.kill(self.gdb_process.pid, signal)
        else:
            raise NoGdbProcessError(
                &#34;Cannot send signal to gdb process because no process exists.&#34;
            )

    def interrupt_gdb(self):
        &#34;&#34;&#34;Send SIGINT (interrupt signal) to the gdb subprocess&#34;&#34;&#34;
        self.send_signal_to_gdb(&#34;SIGINT&#34;)

    def exit(self):
        &#34;&#34;&#34;Terminate gdb process
        Returns: None&#34;&#34;&#34;
        if self.gdb_process:
            self.gdb_process.terminate()
            self.gdb_process.communicate()
        self.gdb_process = None
        return None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pygdbmi.gdbcontroller.GdbController.exit"><code class="name flex">
<span>def <span class="ident">exit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Terminate gdb process
Returns: None</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exit(self):
    &#34;&#34;&#34;Terminate gdb process
    Returns: None&#34;&#34;&#34;
    if self.gdb_process:
        self.gdb_process.terminate()
        self.gdb_process.communicate()
    self.gdb_process = None
    return None</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.get_gdb_response"><code class="name flex">
<span>def <span class="ident">get_gdb_response</span></span>(<span>self, timeout_sec=1, raise_error_on_timeout=True, return_on_first_response=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get response from GDB, and block while doing so. If GDB does not have any response ready to be read
by timeout_sec, an exception is raised.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout_sec</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum time to wait for reponse. Must be &gt;= 0. Will return after</dd>
<dt><strong><code>raise_error_on_timeout</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether an exception should be raised if no response was found after timeout_sec</dd>
<dt><strong><code>return_on_first_response</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return as soon as at least one response from gdb has been parsed. This may result in faster return times, but also may leave some arguments remaining to be parsed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code> of <code>parsed</code> <code>GDB</code> <code>responses</code>, <code>returned</code> <code>from</code> <code>gdbmiparser.parse_response</code>, <code>with</code> <code>the</code></dt>
<dd>&nbsp;</dd>
<dt><code>additional</code> <code>key</code> <code>'stream'</code> <code>which</code> <code>is</code> <code>either</code> <code>'stdout'</code> or <code>'stderr'</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><a title="pygdbmi.gdbcontroller.GdbTimeoutError" href="#pygdbmi.gdbcontroller.GdbTimeoutError"><code>GdbTimeoutError</code></a> <code>if</code> <code>response</code> <code>is</code> <code>not</code> <code>received</code> <code>within</code> <code>timeout_sec</code></dt>
<dd>&nbsp;</dd>
<dt><code>ValueError</code> <code>if</code> <code>select</code> <code>returned</code> <code>unexpected</code> <code>file</code> <code>number</code></dt>
<dd>&nbsp;</dd>
<dt><a title="pygdbmi.gdbcontroller.NoGdbProcessError" href="#pygdbmi.gdbcontroller.NoGdbProcessError"><code>NoGdbProcessError</code></a> <code>if</code> <code>there</code> <code>is</code> <code>no</code> <code>gdb</code> <code>subprocess</code> <code>running</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_gdb_response(
    self,
    timeout_sec: float = DEFAULT_GDB_TIMEOUT_SEC,
    raise_error_on_timeout=True,
    return_on_first_response=False,
):
    &#34;&#34;&#34;Get response from GDB, and block while doing so. If GDB does not have any response ready to be read
    by timeout_sec, an exception is raised.

    Args:
        timeout_sec (float): Maximum time to wait for reponse. Must be &gt;= 0. Will return after
        raise_error_on_timeout (bool): Whether an exception should be raised if no response was found after timeout_sec
        return_on_first_response (bool): Return as soon as at least one response from gdb has been parsed. This may result in faster return times, but also may leave some arguments remaining to be parsed.

    Returns:
        List of parsed GDB responses, returned from gdbmiparser.parse_response, with the
        additional key &#39;stream&#39; which is either &#39;stdout&#39; or &#39;stderr&#39;

    Raises:
        GdbTimeoutError if response is not received within timeout_sec
        ValueError if select returned unexpected file number
        NoGdbProcessError if there is no gdb subprocess running
    &#34;&#34;&#34;

    self.verify_valid_gdb_subprocess()
    if timeout_sec &lt; 0:
        self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
        timeout_sec = 0

    if USING_WINDOWS:
        retval = self._get_responses_windows(timeout_sec, return_on_first_response)
    else:
        retval = self._get_responses_unix(timeout_sec, return_on_first_response)

    if not retval and raise_error_on_timeout:
        raise GdbTimeoutError(
            &#34;Did not get response from gdb after %s seconds&#34; % timeout_sec
        )

    else:
        return retval</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.get_subprocess_cmd"><code class="name flex">
<span>def <span class="ident">get_subprocess_cmd</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the shell-escaped string used to invoke the gdb subprocess.
This is a string that can be executed directly in a shell.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_subprocess_cmd(self):
    &#34;&#34;&#34;Returns the shell-escaped string used to invoke the gdb subprocess.
    This is a string that can be executed directly in a shell.
    &#34;&#34;&#34;
    return &#34; &#34;.join(quote(c) for c in self.cmd)</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.interrupt_gdb"><code class="name flex">
<span>def <span class="ident">interrupt_gdb</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Send SIGINT (interrupt signal) to the gdb subprocess</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def interrupt_gdb(self):
    &#34;&#34;&#34;Send SIGINT (interrupt signal) to the gdb subprocess&#34;&#34;&#34;
    self.send_signal_to_gdb(&#34;SIGINT&#34;)</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.send_signal_to_gdb"><code class="name flex">
<span>def <span class="ident">send_signal_to_gdb</span></span>(<span>self, signal_input)</span>
</code></dt>
<dd>
<section class="desc"><p>Send signal name (case insensitive) or number to gdb subprocess
gdbmi.send_signal_to_gdb(2)
# valid
gdbmi.send_signal_to_gdb('sigint')
# also valid
gdbmi.send_signal_to_gdb('SIGINT')
# also valid</p>
<p>raises ValueError if signal_input is invalie
raises NoGdbProcessError if there is no gdb process to send a signal to</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def send_signal_to_gdb(self, signal_input):
    &#34;&#34;&#34;Send signal name (case insensitive) or number to gdb subprocess
    gdbmi.send_signal_to_gdb(2)  # valid
    gdbmi.send_signal_to_gdb(&#39;sigint&#39;)  # also valid
    gdbmi.send_signal_to_gdb(&#39;SIGINT&#39;)  # also valid

    raises ValueError if signal_input is invalie
    raises NoGdbProcessError if there is no gdb process to send a signal to
    &#34;&#34;&#34;
    try:
        signal = int(signal_input)
    except Exception:
        signal = SIGNAL_NAME_TO_NUM.get(signal_input.upper())

    if not signal:
        raise ValueError(
            &#39;Could not find signal corresponding to &#34;%s&#34;&#39; % str(signal)
        )

    if self.gdb_process:
        os.kill(self.gdb_process.pid, signal)
    else:
        raise NoGdbProcessError(
            &#34;Cannot send signal to gdb process because no process exists.&#34;
        )</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.spawn_new_gdb_subprocess"><code class="name flex">
<span>def <span class="ident">spawn_new_gdb_subprocess</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Spawn a new gdb subprocess with the arguments supplied to the object
during initialization. If gdb subprocess already exists, terminate it before
spanwing a new one.
Return int: gdb process id</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def spawn_new_gdb_subprocess(self):
    &#34;&#34;&#34;Spawn a new gdb subprocess with the arguments supplied to the object
    during initialization. If gdb subprocess already exists, terminate it before
    spanwing a new one.
    Return int: gdb process id
    &#34;&#34;&#34;
    if self.gdb_process:
        self.logger.debug(
            &#34;Killing current gdb subprocess (pid %d)&#34; % self.gdb_process.pid
        )
        self.exit()

    self.logger.debug(&#39;Launching gdb: &#34;%s&#34;&#39; % &#34; &#34;.join(self.cmd))

    # Use pipes to the standard streams
    self.gdb_process = subprocess.Popen(
        self.cmd,
        shell=False,
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
        stderr=subprocess.PIPE,
        bufsize=0,
    )

    _make_non_blocking(self.gdb_process.stdout)
    _make_non_blocking(self.gdb_process.stderr)

    # save file numbers for use later
    self.stdout_fileno = self.gdb_process.stdout.fileno()
    self.stderr_fileno = self.gdb_process.stderr.fileno()
    self.stdin_fileno = self.gdb_process.stdin.fileno()

    self.read_list = [self.stdout_fileno, self.stderr_fileno]
    self.write_list = [self.stdin_fileno]

    # string buffers for unifinished gdb output
    self._incomplete_output = {&#34;stdout&#34;: None, &#34;stderr&#34;: None}
    return self.gdb_process.pid</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.verify_valid_gdb_subprocess"><code class="name flex">
<span>def <span class="ident">verify_valid_gdb_subprocess</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Verify there is a process object, and that it is still running.
Raise NoGdbProcessError if either of the above are not true.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def verify_valid_gdb_subprocess(self):
    &#34;&#34;&#34;Verify there is a process object, and that it is still running.
    Raise NoGdbProcessError if either of the above are not true.&#34;&#34;&#34;
    if not self.gdb_process:
        raise NoGdbProcessError(&#34;gdb process is not attached&#34;)

    elif self.gdb_process.poll() is not None:
        raise NoGdbProcessError(
            &#34;gdb process has already finished with return code: %s&#34;
            % str(self.gdb_process.poll())
        )</code></pre>
</details>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbController.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, mi_cmd_to_write, timeout_sec=1, raise_error_on_timeout=True, read_response=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mi_cmd_to_write</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>String to write to gdb. If list, it is joined by newlines.</dd>
<dt><strong><code>timeout_sec</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum number of seconds to wait for response before exiting. Must be &gt;= 0.</dd>
<dt><strong><code>raise_error_on_timeout</code></strong> :&ensp;<code>bool</code></dt>
<dd>If read_response is True, raise error if no response is received</dd>
<dt><strong><code>read_response</code></strong> :&ensp;<code>bool</code></dt>
<dd>Block and read response. If there is a separate thread running,</dd>
</dl>
<p>this can be false, and the reading thread read the output.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code> of <code>parsed</code> <code>gdb</code> <code>responses</code> <code>if</code> <code>read_response</code> <code>is</code> <code>True</code>, <code>otherwise</code> []</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><a title="pygdbmi.gdbcontroller.NoGdbProcessError" href="#pygdbmi.gdbcontroller.NoGdbProcessError"><code>NoGdbProcessError</code></a> <code>if</code> <code>there</code> <code>is</code> <code>no</code> <code>gdb</code> <code>subprocess</code> <code>running</code></dt>
<dd>&nbsp;</dd>
<dt><code>TypeError</code> <code>if</code> <code>mi_cmd_to_write</code> <code>is</code> <code>not</code> <code>valid</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write(
    self,
    mi_cmd_to_write: Union[str, List[str]],
    timeout_sec=DEFAULT_GDB_TIMEOUT_SEC,
    raise_error_on_timeout: bool = True,
    read_response: bool = True,
):
    &#34;&#34;&#34;Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec.

    Args:
        mi_cmd_to_write (str or list): String to write to gdb. If list, it is joined by newlines.
        timeout_sec (float): Maximum number of seconds to wait for response before exiting. Must be &gt;= 0.
        raise_error_on_timeout (bool): If read_response is True, raise error if no response is received
        read_response (bool): Block and read response. If there is a separate thread running,
        this can be false, and the reading thread read the output.
    Returns:
        List of parsed gdb responses if read_response is True, otherwise []
    Raises:
        NoGdbProcessError if there is no gdb subprocess running
        TypeError if mi_cmd_to_write is not valid
    &#34;&#34;&#34;
    self.verify_valid_gdb_subprocess()
    if timeout_sec &lt; 0:
        self.logger.warning(&#34;timeout_sec was negative, replacing with 0&#34;)
        timeout_sec = 0

    # Ensure proper type of the mi command
    if isinstance(mi_cmd_to_write, str):
        mi_cmd_to_write_str = mi_cmd_to_write
    elif isinstance(mi_cmd_to_write, list):
        mi_cmd_to_write_str = &#34;\n&#34;.join(mi_cmd_to_write)
    else:
        raise TypeError(
            &#34;The gdb mi command must a be str or list. Got &#34;
            + str(type(mi_cmd_to_write))
        )

    self.logger.debug(&#34;writing: %s&#34;, mi_cmd_to_write)

    if not mi_cmd_to_write_str.endswith(&#34;\n&#34;):
        mi_cmd_to_write_nl = mi_cmd_to_write_str + &#34;\n&#34;
    else:
        mi_cmd_to_write_nl = mi_cmd_to_write_str

    if USING_WINDOWS:
        # select not implemented in windows for pipes
        # assume it&#39;s always ready
        outputready = [self.stdin_fileno]
    else:
        _, outputready, _ = select.select([], self.write_list, [], timeout_sec)
    for fileno in outputready:
        if fileno == self.stdin_fileno:
            # ready to write
            self.gdb_process.stdin.write(  # type: ignore
                mi_cmd_to_write_nl.encode()
            )
            # don&#39;t forget to flush for Python3, otherwise gdb won&#39;t realize there is data
            # to evaluate, and we won&#39;t get a response
            self.gdb_process.stdin.flush()  # type: ignore
        else:
            self.logger.error(&#34;got unexpected fileno %d&#34; % fileno)

    if read_response is True:
        return self.get_gdb_response(
            timeout_sec=timeout_sec, raise_error_on_timeout=raise_error_on_timeout
        )

    else:
        return []</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pygdbmi.gdbcontroller.GdbTimeoutError"><code class="flex name class">
<span>class <span class="ident">GdbTimeoutError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Raised when no response is recieved from gdb after the timeout has been triggered</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class GdbTimeoutError(ValueError):
    &#34;&#34;&#34;Raised when no response is recieved from gdb after the timeout has been triggered&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pygdbmi.gdbcontroller.NoGdbProcessError"><code class="flex name class">
<span>class <span class="ident">NoGdbProcessError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Raise when trying to interact with gdb subprocess, but it does not exist.
It may have been killed and removed, or failed to initialize for some reason.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NoGdbProcessError(ValueError):
    &#34;&#34;&#34;Raise when trying to interact with gdb subprocess, but it does not exist.
    It may have been killed and removed, or failed to initialize for some reason.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygdbmi" href="index.html">pygdbmi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pygdbmi.gdbcontroller.GdbController" href="#pygdbmi.gdbcontroller.GdbController">GdbController</a></code></h4>
<ul class="">
<li><code><a title="pygdbmi.gdbcontroller.GdbController.exit" href="#pygdbmi.gdbcontroller.GdbController.exit">exit</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.get_gdb_response" href="#pygdbmi.gdbcontroller.GdbController.get_gdb_response">get_gdb_response</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.get_subprocess_cmd" href="#pygdbmi.gdbcontroller.GdbController.get_subprocess_cmd">get_subprocess_cmd</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.interrupt_gdb" href="#pygdbmi.gdbcontroller.GdbController.interrupt_gdb">interrupt_gdb</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.send_signal_to_gdb" href="#pygdbmi.gdbcontroller.GdbController.send_signal_to_gdb">send_signal_to_gdb</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.spawn_new_gdb_subprocess" href="#pygdbmi.gdbcontroller.GdbController.spawn_new_gdb_subprocess">spawn_new_gdb_subprocess</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.verify_valid_gdb_subprocess" href="#pygdbmi.gdbcontroller.GdbController.verify_valid_gdb_subprocess">verify_valid_gdb_subprocess</a></code></li>
<li><code><a title="pygdbmi.gdbcontroller.GdbController.write" href="#pygdbmi.gdbcontroller.GdbController.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygdbmi.gdbcontroller.GdbTimeoutError" href="#pygdbmi.gdbcontroller.GdbTimeoutError">GdbTimeoutError</a></code></h4>
</li>
<li>
<h4><code><a title="pygdbmi.gdbcontroller.NoGdbProcessError" href="#pygdbmi.gdbcontroller.NoGdbProcessError">NoGdbProcessError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>